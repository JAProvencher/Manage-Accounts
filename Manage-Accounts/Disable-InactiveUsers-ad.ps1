<#
.SYNOPSIS
  Disables accounts that haven't logged on for 30+ days

.DESCRIPTION
  This script will look at all accounts that haven't logged on for 23 days.  Any accounts that are
  reported as active via comparison with SPLUNK data are removed.  The remaining are evaluated by
  checking the lastlogon property for the account on each domain controller.  The latest is kept, but
  if it is blank, the WhenCreated date is used.
  
  The script checks to see if the account is protected by AdminSDHolder.  If it is, the script cannot
  disable the account and notification is sent to the Account Management Team (AMT), copied to the 
  HelpDesk to generate a ticket and to the user for notification.
  
.PARAMETER
	None

.INPUTS
  None

.OUTPUTS
  Log file stored in the script folder\scriptname_Logs\Script_[datestring].log
  CSV file for processing by helpdesk

.NOTES
  Version:        6.2
  Author:         John Provencher
  Creation Date:  05/13/2014
  Purpose/Change: Re-write of original script
  
05/29/2014 (5.0) -	Changed how  the lookup is done for inactive accounts.  There are cases where samaccountname
					is not the same as name.  Originally, 'Name' was used in comparing against SPLUNK data.
					Now, a custom property named 'AccountsInSPLUNK' is created to match the SPLUNK data.  It was
					easier to do this than to have the SPLUNK administrator change the column headings.  I
					do not know who else uses the data where their process could depend on the property names.
					Instead of returning all the data, then again querying it, I have it only retrieve the name
					(AccountsInSPLUNK) and compare that against the SPLUNK data.  After the compare, a query of
					Active Directory is made to pull the necessary information for further account checks.
06/12/2014 (6.1a) -	Changed the note for NWPT users to include a link to Newportal.
07/30/2014 (6.1b) - Changed email address for Account Management Team
08/19/2014 (6.1c) -	Changed intranet link to point to new website.
08/27/2014 (6.1d) -	Removed "Number of times disabled...." from log.  The attribute referenced is not longer used, and it
					didn't work as expected.  It worked from the shell, but didn't from the script.
10/27/2014 (6.1e) -	Changed Compare so that 'Active' data from SPLUNK is included.
07/16/2014 - 6.1f -	Changed compare-object to include object in both $active and $inactive.  Some users were getting disabled without
					notification due to being present in data from SPLUNK.
07/30/2014 - 		Changed email address for Account Management Team
11/6/2014  (6.2)	-	Removed SPLUNK from process.  Share had been removed, and including it keeps users from being notified properly
						before being disabled. It was found out that they wouldn't get notified if their account was in the SPLUNK data which
						spans 30 days.  If the user hadn't logged on in 23+ days, and their account was listed in the SPLUNK data, they
						were seen as 'Active' and not receive a warning email.
#>

$today=get-date -format dd-MMM-yy # Date used when annotating the user's description
$date=get-date -format d
$datestring=get-date -format yyyyMMdd # Date used in output file names
$setdesc="Dormant account disabled $today" # Text appended to user's description
$srcdomain=$env:userdomain #What domain is this running in?
$splunkdata="\\902spl01.nptrdte.nuwc.navy.mil\splunk\Active_$srcdomain.csv" # Data generated by SPLUNK
$emptyemail=@()
$disabled=@()
$Helpdesk="NUWC_NPT_Helpdesk@navy.mil" # Email address for the Helpdesk group
$scriptpath=Split-Path $script:MyInvocation.MyCommand.Path
$ScriptName = $MyInvocation.mycommand.name
$logdir=$MyInvocation.MyCommand.path.Replace(".ps1","")+"_logs"
$LogName = $ScriptName.replace(".ps1", "_$datestring.log")
$logpath=$logdir+"\"+$logname
$MaxLogFileSizeMB=5  # Maximum size for the log file in MB
$version="6.2"
trap
[Exception] { 
sendl "error: $($_.Exception.GetType().Name) - $($_.Exception.Message)" 
}
#*******************************************************************************************************
#Load functions
#*******************************************************************************************************
# Check for the log file.  Create if it doesn't exist.  I set it up to use a new log file for each day
# but it can be modified to continually append and the function will archive the log and start a new one
#
function LogFileCheck
{

	if (!(Test-Path $LogDir -erroraction "SilentlyContinue")) # Check if log file directory exists - if not, create and then create log file for this script.
	{
		mkdir $LogDir
		New-Item "$LogPath" -type file
	}
	if (((gci $LogPath).length/1MB) -gt $MaxLogFileSizeMB) # Check size of log file - to stop unweildy size, archive existing file if over limit and create fresh. 
	{
		$NewLogFile = $LogName.replace(".log", " ARCHIVED $(Get-Date -Format dd-MM-yyy-hh-mm-ss).log")
		ren $Logpath $LogDir\$NewLogFile
	}
}
#*******************************************************************************************************
# Send an entry to the log file
#
function sendl ([string]$message) # Send to log file 
{
	$toOutput = "$(get-date) > $message " | Out-File $logpath -append -NoClobber
}


#*******************************************************************************************************
# Gets the user's most current logon date/time.  If the user hasn't logged on, the function
# returns the date the account was created.  This will help avoid having stale accounts that were
# created but never used.
#

function Get-ADUserLastLogon
{
[cmdletbinding()]
	param($user)
	$dcs=get-addomaincontroller -filter *|Select-Object -expandproperty hostname|Where-Object {test-connection -computername $_ -count 1 -ea 0}
	$llo=0
	$tmptime=0
	$wc=$user.whencreated.tofiletime()
	foreach($dc in $dcs)
	{
		$tmptime=(get-aduser $user -property lastlogon -server $dc).lastlogon
		$llo=$llo,$tmptime|Sort-Object -descending|Select-Object -first 1
	}
	$llo=$llo,$user.lastlogontimestamp,$wc,$user."msDS-LastSuccessfulInteractiveLogonTime"|Sort-Object -descending|Select-Object -first 1
	$llo=[datetime]::fromfiletime($llo)
	if(!$user.lastlogontimestamp){$llo=$llo.adddays(30)}
	return $llo
}
#*******************************************************************************************************
# Get the appropriate action for the user.  Makes call to Get-ADUserLastLogon. 
Function Check-User
{
	[CmdletBinding()]
	Param([Parameter(ValueFromPipeline=$true)]
	$user)
	Begin
	{
		$action="Okay"
	}
	Process
	{
		$global:logondate=get-aduserlastlogon($user.samaccountname)
		if ($logondate -eq "Never")
		{
		$global:logondate=$user.whencreated
		sendl "$user has never logged on. Reverting to creation date of $($user.whencreated)"
		}

		$userdisable=$logondate.adddays(30)
		$global:D2D=($userdisable-(Get-Date)).days

		If($D2D -le 0)
		{
			$action="Disable" 
		}
		elseif ($d2d -le 7)
		{
			$action="Warn"
		}
	}
	End
	{
		Return $action
	}
}
#*******************************************************************************************************
# Check to see if user has an email address associated with their account
function Check-Email
{
	[CmdletBinding()]
	param($user)
	if($user.email)
	{
		return $true
	}
	else
	{
		return $false
	}
}
#*******************************************************************************************************
#Determine if the user is protected by AdminSDHolder
Function Is-Admin{
	[CmdletBinding()]
	Param(
	[Parameter(ValueFromPipeline=$true,Mandatory=$true)]$user)
	Begin{
	$admin=$false
	}
	Process{
		$admin=($user.admincount -eq 1)
	}
	End
	{
		Return $admin
	}
}
	
#*******************************************************************************************************
# Is it a weekend?
<#function is-weekend{
	((get-date).dayofweek -in "Saturday","Sunday")
}
#>
#*******************************************************************************************************
#Main body of script
#*******************************************************************************************************

LogfileCheck
sendl "$("*"*80)"
sendl "Beginning $scriptname version $version"
sendl "$("*"*80)"
try
{
	if ((Get-PSSnapin -name Quest.Activeroles.Admanagement) -eq $null)
	{
		Add-PSSnapin Quest.Activeroles.Admanagement -erroraction stop
		sendl "Quest snapin loaded"
	}
}
catch
{
	sendl "An error occured loading the AD Snapin"
	break
}

sendl "Loading variables"

$AcctMgmt="NWPT.NUWC_NPT_10411_Account_Mgmt@navy.mil"
$Notify=@{
From=$AcctMgmt
SMTPServer="SMTP"
}


$global:msgbody=@"
You are receiving this message because the above named account is within a week of being out of compliance.`n

Accounts must be logged into at least once every 30 days.  Failing to do this puts the account out of
compliance with mandated guidelines.  If your account falls outside compliance, it will be disabled.  If `
subsequent action is not taken, it will be deleted.`n

If your account has been disabled, please contact your department's `
Information Assurance Officer (IAO) to submit a request to have it enabled.  If no action is taken and your `
account is deleted, paperwork requesting account establishment must be submitted to the Accounts Management Team `
through your IAO.`n`n
"@

$global:msgclosing=@"
`nThank you,`n
Account Management Team
"@


sendl "Begin processing"
sendl "$("*"*80)"
	
Foreach ($check in $tocheck)
{
	if($check.domain.name -eq "nwpt"){$note=@"
This is the account used to access Newportal, loss of which will inhibit access to NUWCDIVNPT resources.
Click here: https://newportalv3.nwpt.nuwc.navy.mil.  If the link is not clickable, copy and paste it into your browser.
"@
}
	$action=Check-User $check
	$salutation="$($check.givenname)"
	
	$Notify.Subject="Important information regarding user account $check. *ACTION REQUIRED*"
	switch ($action) {			# Determine course of action based on value of variable
	
	# Warn user of pending account disabling
	"Warn" {

		# Set up body of outgoing message - Warning user
		$body=@"
$salutation,`n
Account $check will be disabled in $D2D days
Last recorded logon: $logondate`n
$note`n
$msgbody`n
$msgclosing
"@
$Notify.Body=$body
		if (Check-Email($check))
		{
			try{
				$Notify.To=$check.email
				Send-MailMessage @Notify
				sendl "Sent warning to $check @ $($check.email). Last logon: $logondate.  Disable in $D2D days." 
			}
			catch
			{
				sendl "Error occurred sending email to $($check.email)"
			}
			
		}
		else
		{
			sendl "$check has a blank email address.  No warning or notification of disable possible"
			$emptyemail+=$check.dn
		}
	sendl "$("*"*80)"
	}
	#Disable account and notify user.  
	"Disable" {			
		if(is-admin $check){			#Is the account protected by AdminSDHolder?  If so, notify AMT
			$notify.To=$AcctMgmt
			$body=@"
Account Management Team,`n
Account $check has been identified as protected, is outside the compliance standards, and needs to be disabled.
Last logon: $logondate
$($check.email) has been CC'd on this email. `n`n
Thank you,`n
Automated Account Management Process
"@
			$Notify.CC=$check.email,$helpdesk		# CC protected user to notify them their account is disabled
			$Notify.Body=$Body
			try{
			Send-MailMessage @Notify
			sendl "$check is protected by AdminSDHolder. Last logon: $logondate. Notified HelpDesk and CC'd user @ $($check.email)"
			$Notify.Remove("CC")
			}
			catch{
			sendl "Error sending mail to $($notify.to)"
			}
		}
		Else
		{
			try{
				$userdesc=(get-aduser $check).description
				sendl "Disable user $check.  Last logon: $logondate"
				disable-adaccount $check
				sendl "Set $check description"
				set-aduser $check -description "$userdesc - $setdesc"
				sendl "Add disable date for reference"
				set-aduser $check -objectattributes @{carlicense=@{Update=@($date)}}
				$disabled+=(get-qaduser $check)
				$body=@"
$salutation,`n
Account $check has been disabled.  If action is not taken, it will be marked for deletion on $((get-date).adddays(15).toshortdatestring())
Last recorded logon: $logondate`n
$note`n
$msgbody`n
$msgclosing
"@
				$Notify.Body=$body
				if (Check-Email($check))
				{			
					try{
						$Notify.To=$check.email
						Send-MailMessage @Notify
						sendl "Notified $check of disabled account @ $($check.email)."
					}
					catch{
						sendl "Error sending email to $($notify.to)"
					}
				}
				else
				{
					sendl "$check has a blank email address.  No warning or notification of disable possible"
					$emptyemail+=$check.dn
				}
				
			}
			catch{
				sendl "Error disabling $check"
			}
		}
		sendl "$("*"*80)"
	}
	"Okay" {
		sendl "$check okay.  Last logon: $logondate"
		sendl "$("*"*80)"
		}
	}
}
# Send log file and list of disabled users to AMT as attachments
sendl "Compile and send report and logs to Account Management Team"
if($disabled.count -ne 0)
{
	$cnt=$disabled.count
	$outpath="C:\Windows\SYSVOL\domain\scripts\DIU\"+$srcdomain+"_Disabled_"+$cnt+"-"+$datestring+".csv"
	$disabled|sort name|
		select @{name="Domain";expression={$srcdomain}},
		name,
		@{name="Status";expression={if($_.accountisdisabled){"Disabled"}else{"Active"}}},
		@{name="Date";e={$today}}|export-csv -path $outpath -notypeinformation
	
	$Notify.To=$AcctMgmt
	$Notify.Attachments=$outpath,$logpath
	$Notify.Subject="$srcdomain Accounts disabled automatically due to last logon age"
	$Notify.Body="A report of accounts disabled has been posted to $outpath.
	These accounts have been disabled due to not having registered a logon in over 30 days."
	Send-MailMessage @Notify
}
else
{
	$Notify.To=$AcctMgmt
	$Notify.Subject="$srcdomain No Accounts disabled automatically due to last logon age"
	$Notify.Body="No accounts were identified as inactive and disabled."
	$Notify.Attachments=$logpath
	Send-Mailmessage @Notify
	Sendl "No accounts were disabled this run"
}
if($emptyemail.count -ne 0)
{
	$Notify.To=$AcctMgmt
	$Notify.Subject="These accounts have been disabled without notification due to an empty email address in AD"
	$Notify.Body="Listed below are accounts that were disabled but have no email address specified in AD.`n`n`n"+($emptyemail|%{$_.displayname}|out-string)
	$Notify.Attachments=$null
	send-mailmessage @Notify
}
sendl "Processing $scriptname completed"
sendl "$("#"*80)"
